# -*- coding: utf-8 -*-
"""flower_classification (2).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FGppxvyfxqJDUHMJDkBnLitn_VKbK7m8
"""

!pip install opendatasets

"""Downloading dataset from kaggle..."""

import opendatasets as od
od.download('https://www.kaggle.com/datasets/alxmamaev/flowers-recognition')

"""Importing the libraries"""

import cv2
import numpy
from tensorflow import keras

from keras.applications.vgg16 import VGG16
from keras.layers import Dense
from keras import Sequential

"""Importing the model VGG16 without the full connected layers"""

base_model = VGG16(include_top = False,weights = 'imagenet',input_shape=(150,150,3))
base_model.summary()

"""Creating our own model by adding the output layers."""

from keras.layers import Flatten
model = Sequential()
model.add(base_model)
model.add(Flatten())
model.add(Dense(1024,activation='relu'))
model.add(Dense(5,activation='softmax'))
base_model.trainable=False
model.summary()

"""Preparing the training and validation dataset"""

from tensorflow import keras
# generators
ds = keras.utils.image_dataset_from_directory(
    directory = '/content/flowers-recognition/flowers',
    labels='inferred',
    label_mode = 'int',
    batch_size=32,
    seed = 10,
    image_size=(150,150),
    validation_split = 0.1,
    subset = "both"
)
print(len(ds[0]))

"""Normalizing the images present in the dataset"""

import tensorflow
# Normalize
def process(image,label):
    image = tensorflow.cast(image/255. ,tensorflow.float32)
    return image,label

ds[0] = ds[0].map(process)
ds[1] = ds[1].map(process)

"""Using early stopping to increase the accuracy of the model"""

callback = tensorflow.keras.callbacks.EarlyStopping(monitor='val_loss', patience=4)

"""Compiling the model using SparseCategoricalCrossentropy loss function"""

model.compile(loss='SparseCategoricalCrossentropy',optimizer= 'adam',metrics=['accuracy'])

"""Fiting the dataset into the model"""

model.fit(x=ds[0],epochs=20,verbose = 2,validation_data=ds[1],callbacks=callback)

"""Calculating the training and test accuracy"""

train_loss, train_acc = model.evaluate(x=ds[0])
test_loss, test_acc   = model.evaluate(x=ds[1])
print("final train accuracy = {:.2f} , Test accuracy = {:.2f}".format(train_acc*100, test_acc*100))